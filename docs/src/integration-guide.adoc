:webservicesdir: ./webservices

== Smarti Integration Guide

The development of Smarti follows an API-driven approach (API-first).

Whenever new features will be released for Smarti, the first step is to develop the corresponding API.
This means that before developing any Apps or other graphical user interfaces, the API already exists: No feature without an API.
This makes it very easy to integrate Smarti into third party applications.

Smarti's web services are basically divided into the following five components:

. <<index.adoc#_conversational_web_service, Conversational Analyzing>>
. <<index.adoc#_conversation_admin_web_service, Conversation Administration>>
. <<index.adoc#_client_configuration_web_service, Client Configuration>>
. <<index.adoc#_user_management_web_service, User Management>>

NOTE: the <<index.adoc#_chat_adapter_web_service, Chat Adapter>> was removed with `v0.7.0`. Most of its functionality was integrated in the <<index.adoc#_conversational_web_service, Conversational Analyzing>> Webservice.


In the following sections each web service is introduced briefly.

The aim of this documentation is to explain every web service at a high level.
It is not the aim of this documentation to learn how the individual API calls work in detail, but rather to understand what the goal of the individual web services is and why they are built as they are.

=== Swagger documentation

**Smarti's web services are designed and documented using Swagger.**
Who is interested in implementing against the RESTful-API should move to Smarti's Swagger API documentation.
If Swagger is new to you, follow this link to familiarize yourself with Swagger:
https://swagger.io/getting-started/[Getting started with Swagger]

At runtime Smarti provides a generated Swagger JSON file that can easily accessed by opening the following URLs within your web browser:

- abstract: `http://${smarti-host}:${smarti-port}/v2/api-docs`
- specific: `http://localhost:8080/v2/api-doc`
- link:swagger.json[Swagger.json] (Copy - part of this documentation)

You can copy & past the raw JSON from `http://${smarti-host}:${smarti-port}/v2/api-docs` into any Swagger editor of your choice.
Alternatively Smarti provides a Swagger user interface to browse the API without using external tools:

- abstract: `http://${smarti-host}:${smarti-port}/swagger-ui.html`
- specific: `http://localhost:8080/swagger-ui.html`


=== Integration tasks
. Preconditions
.. Setup Smarti
.. Create a client
.. Create a client configuration
.. Create a client auth token
. Chat Integration
.. Store the auth token
.. Authenticate each request
.. Adapt Smarti into Chat (onMessage, callback, onClose)
.. Implement a backend for the integration widget/bot
. User Interface
.. Implement a widget

=== RESTful-Integration Sequence

The `/conversation` service supports CRUD functionality for Conversation. In Smarti Conversational data are represented by Conversations that contain messages. Data of the chat server need to mapped to this model.

The simplest model is to map a channel/room of the chat to a single conversation in Smarti. All messages in that channel/room can be added as messages to the conversation. However integrators may also choose different mappings. In any way, the mapping between channel/rooms and conversations in in the responsibility of the integrator. While it is possible to store channel/room IDs with the conversation it is the responsibility of the integrator to provide this mapping.


image::chat-sequence-REST-sync.png[RESTful-Integration Sequence]

. Create a Conversation: The payload for this operation is optional. If no payload is present Smarti will create an empty conversation and assign an unique ID to it. If a payload is present the provided data are stored. The provided conversation can contain any data (such as existing messages). The ID is always assigned by Smarti.
. Append a Message: Messages are assigned to conversations therefore all CRUD operations on Messages are in the context of an existing conversation. Smarti allows to set IDs of messages (assumed to be unique within the conversation). Integrators can therefore use message IDs of their chat system. If no message IDs are parsed Smarti will assign a server generated unique ID messages created.
. Analysis results for the current state of the conversation. This is an expensive operation. So response time might be longer. To mitigate this Smarti per-processes analysis on changes to conversations. So retrieving an analysis for a conversation that has not changed recently is typically fast. When called immediately after an update response times are expected to be longer. The following section provides more information retrieving analysis results asynchronous via a callback.
. Update conversation fields: Smarti allows to store meta infomation for conversation and messages. Those can be updated and deleted. The key of the field is part of the request path. The value is represented by the JSON playload. 
. Complete Conversation: by setting the `staus` field to `"completed"`. Completion of a Conversation does NOT prevent from future modifications, but as an indicator that the conversation is in a state so that it can be used as an information source. Several components allow to exclude none completed conversations from results and suggestions.

As the analysis of conversation is an expensive opertation the `conversation` service supports asynchronous callbacks for analysis results. This mode is activating by parsing the `callback` parameter in requests to the conversation service. Most of the CRUD service do support this parameter (for details see the Swagger documentation).The following figure shows how this works. 

image::chat-sequence-REST-async.png[RESTful-Integration Sequence]

. Create a Conversation: Assuming the `callback` parameter is present the data of the created conversation are returned synchronously while the analysis results are `POST` to the provided callback as soon as the analysis is completed.
.. The callback receives an `Analysis` object that referes the conversation. The state of the conversation (as analysed) is given by the modification date.
. Append a Message: As with the sync workflow the added message is sent back synchronously.
.. The callback receives an updates `Analysis` as soon as its completes processing.
. On Analysis requests providing a `callback` the request is confrimed by a `202 Accepted` response
.. The analysis results are sent to the provided `callback` as soon as they are available 


include::{webservicesdir}/conversation-api.adoc[]

include::{webservicesdir}/rocketchat-api.adoc[]

include::{webservicesdir}/client-api.adoc[]

include::{webservicesdir}/conversation-admin-api.adoc[]

include::{webservicesdir}/user-api.adoc[]
